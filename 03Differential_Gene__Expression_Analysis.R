library(tidyverse)
library(tximport)
library(edgeR)
library(limma)
library(cowplot)
library(matrixStats)
library(gt)
library(DT)
library(plotly)

#set working directory
setwd("/media/sangien/1B17AC667A6936C0/ubuntu/sangien/Downloads/Sanaa/new_kallisto_output/")

#read in study design
targets <- read.csv("sample_design.csv")

#create file paths to the abundance files generated by Kallisto using the 'file.path' function
path <- file.path(targets$sample, "abundance.tsv") # set file paths to your mapped data
# now check to make sure this path is correct by seeing if the files exist
all(file.exists(path)) 

#import gtf file
library(rtracklayer)
gtf_file <- rtracklayer::import("Final_transcriptome_stringTie.gtf")
library(tibble)
aesAnno <- as_tibble(gtf_file)
aes_anno <- aesAnno[,c("transcript_id", "gene_id")] 

# import Kallisto transcript counts into R using Tximport
txi <- tximport(path, 
                    type = "kallisto", 
                    tx2gene = aes_anno,
                    txIn = T,
                    txOut = F, #How does the result change if this =FALSE vs =TRUE?
                    countsFromAbundance = "lengthScaledTPM",
                    ignoreTxVersion = F)

# capture sample labels from the study design file that you worked with and saved as 'targets' in step 1
targets
sampleLabels <- targets$sample

# Make a DGElist from your counts, and plot
myCounts <- txi$counts
myDGEList <- DGEList(myCounts) #Use 'DGEList' function from edgeR to make a list of to raw counts as all the package like deseq2 , limma , edger take count data into consideration
save(myDGEList, file = "myDGEList")

# use the 'cpm' function from EdgeR to get counts per million, similar to TPM but at the gene level
cpm <- cpm(myDGEList) 
log2.cpm <- cpm(myDGEList, log=TRUE)
# 'coerce' your data matrix to a dataframe so that you can use tidyverse tools on it
log2.cpm.df <- as_tibble(log2.cpm, rownames = "geneID") #data frame does not consider rownames so we force it to consider it 

# add your sample names to this dataframe (we lost these when we read our data in with tximport)
colnames(log2.cpm.df) <- c("geneID", sampleLabels)
# use the tidy package to 'pivot' your dataframe (from wide to long)
log2.cpm.df.pivot <- pivot_longer(log2.cpm.df, # dataframe to be pivoted
                                  cols = B0_AR_1:LCM_Bplus_Root_3, # column names to be stored as a SINGLE variable
                                  names_to = "samples", # name of that new variable (column)
                                  values_to = "expression") # name of new variable (column) storing all the values (data)

p1 <- ggplot(log2.cpm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Rotate x-axis labels by 45 degrees
  theme(axis.text.x = element_text(size = 8))  # Adjust font size of x-axis labels
theme_bw()

#Filter the data
#adjust the cutoff for the number of samples in the smallest group of comparison.
keepers <- rowSums(cpm>1)>=3
# now use base R's simple subsetting method to filter your DGEList based on the logical produced above
myDGEList.filtered <- myDGEList[keepers,]

log2.cpm.filtered <- cpm(myDGEList.filtered, log=TRUE)
log2.cpm.filtered.df <- as_tibble(log2.cpm.filtered, rownames = "geneID")
colnames(log2.cpm.filtered.df) <- c("geneID", sampleLabels)
# pivot this FILTERED data, just as you did earlier
log2.cpm.filtered.df.pivot <- pivot_longer(log2.cpm.filtered.df, # dataframe to be pivoted
                                           cols = B0_AR_1:LCM_Bplus_Root_3, # column names to be stored as a SINGLE variable
                                           names_to = "samples", # name of that new variable (column)
                                           values_to = "expression") # name of new variable (column) storing all the values (data)

p2 <- ggplot(log2.cpm.filtered.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, non-normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Rotate x-axis labels by 45 degrees
  theme(axis.text.x = element_text(size = 8))  # Adjust font size of x-axis labels
theme_bw()

#Normalize the data
myDGEList.filtered.norm <- calcNormFactors(myDGEList.filtered, method = "TMM")

# use the 'cpm' function from EdgeR to get counts per million from your normalized data
log2.cpm.filtered.norm <- cpm(myDGEList.filtered.norm, log=TRUE)
log2.cpm.filtered.norm.df <- as_tibble(log2.cpm.filtered.norm, rownames = "geneID")
colnames(log2.cpm.filtered.norm.df) <- c("geneID", sampleLabels)
# pivot this NORMALIZED data, just as you did earlier
log2.cpm.filtered.norm.df.pivot <- pivot_longer(log2.cpm.filtered.norm.df, # dataframe to be pivoted
                                                cols = B0_AR_1:LCM_Bplus_Root_3, # column names to be stored as a SINGLE variable
                                                names_to = "samples", # name of that new variable (column)
                                                values_to = "expression") # name of new variable (column) storing all the values (data)


p3 <-  ggplot(log2.cpm.filtered.norm.df.pivot) +
  aes(x=samples, y=expression, fill=samples) +
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun = "median", 
               geom = "point", 
               shape = 95, 
               size = 10, 
               color = "black", 
               show.legend = FALSE) +
  labs(y="log2 expression", x = "sample",
       title="Log2 Counts per Million (CPM)",
       subtitle="filtered, TMM normalized",
       caption=paste0("produced on ", Sys.time())) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Rotate x-axis labels by 45 degrees
  theme(axis.text.x = element_text(size = 8))  # Adjust font size of x-axis labels
theme_bw()
plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), label_size = 12)

# Identify variables of interest in study design file ----
group <- targets$type
group <- factor(group) 

# Principal component analysis (PCA) -------------
pca.res <- prcomp(t(log2.cpm.filtered.norm), scale.=F, retx=T)
pc.var<-pca.res$sdev^2 # sdev^2 captures these eigenvalues from the PCA result
pc.per<-round(pc.var/sum(pc.var)*100, 1) # we can then use these eigenvalues to calculate the percentage variance explained by each PC
pc.per
# Visualize your PCA result
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
  aes(x=PC1, y=PC2, label=sampleLabels, color=group) +
  geom_point(size=3) +
  #geom_label() +
  #stat_ellipse(level = 0.95) +
  xlab(paste0("PC1 (",pc.per[1],"%",")")) + 
  ylab(paste0("PC2 (",pc.per[2],"%",")")) +
  labs(title="PCA plot") +
  coord_fixed() +
  theme_bw()
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
  aes(x=PC3, y=PC4, label=sampleLabels, color=group) +
  geom_point(size=3) +
  #geom_label() +
  #stat_ellipse(level = 0.95) +
  xlab(paste0("PC3 (",pc.per[3],"%",")")) + 
  ylab(paste0("PC4 (",pc.per[4],"%",")")) +
  labs(title="PCA plot") +
  coord_fixed() +
  theme_bw()

# Set up design matrix
groups <- factor(targets$type)
design <- model.matrix(~0 + groups)
colnames(design) <- levels(groups)
colnames(design) <- gsub(" ", "", colnames(design))

# Use VOOM function from Limma package to model the mean-variance relationship
v.DEGList.filtered.norm <- voom(myDGEList.filtered.norm, design, plot = TRUE)

# fit a linear model to your data
fit <- lmFit(v.DEGList.filtered.norm, design)


# Contrast matrix ----
contrast.matrix.AR <- makeContrasts(AR = ARBplus - ARB0,levels=design)

fits.AR <- contrasts.fit(fit, contrast.matrix.AR)

#get bayesian stats for your linear model fit
ebFit.AR <- eBayes(fits.AR)

# TopTable to view DEGs -----
myTopHits.AR <- topTable(ebFit, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.AR <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.AR)
summary(results.AR)
vennDiagram(results.AR, include="up")
vennDiagram(results.AR, include="down")
upregulated_genes.AR <- rownames(ebFit.AR)[results.AR == 1]
write.table(upregulated_genes.AR, file = "upregulatedAR.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.AR <- rownames(ebFit.AR)[results.AR == -1]
write.table(downregulated_genes.AR, file = "downregulatedAR.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#Repeat the same for every contrast
# Contrast matrix ----
#Anther
contrast.matrix.Anther <- makeContrasts(Anther = AntherBplus - AntherB0,levels=design)

fits.Anther <- contrasts.fit(fit, contrast.matrix.Anther)

#get bayesian stats for your linear model fit
ebFit.Anther <- eBayes(fits.Anther)

# TopTable to view DEGs -----
myTopHits.Anther <- topTable(ebFit.Anther, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.Anther <- decideTests(ebFit.Anther, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.Anther)
summary(results.Anther)
vennDiagram(results.Anther, include="up")
upregulated_genes.Anther <- rownames(ebFit.Anther)[results.Anther == 1]
write.table(upregulated_genes.Anther, file = "upregulatedAnther.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.Anther <- rownames(ebFit.Anther)[results.Anther == -1]
write.table(downregulated_genes.Anther, file = "downregulatedAnther.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#LCMLeaf
contrast.matrix.LCMLeaf <- makeContrasts(LCMLeaf = LCMyoungLeafBplus - LCMyoungLeafB0,levels=design)

fits.LCMLeaf <- contrasts.fit(fit, contrast.matrix.LCMLeaf)

#get bayesian stats for your linear model fit
ebFit.LCMLeaf <- eBayes(fits.LCMLeaf)

# TopTable to view DEGs -----
myTopHits.LCMLeaf <- topTable(ebFit.LCMLeaf, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.LCMLeaf <- decideTests(ebFit.LCMLeaf, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.LCMLeaf)
summary(results.LCMLeaf)
vennDiagram(results.LCMLeaf, include="up")
upregulated_genes.LCMLeaf <- rownames(ebFit.LCMLeaf)[results.LCMLeaf == 1]
write.table(upregulated_genes.LCMLeaf, file = "upregulatedLCMLeaf.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.LCMLeaf <- rownames(ebFit.LCMLeaf)[results.LCMLeaf == -1]
write.table(downregulated_genes.LCMLeaf, file = "downregulatedLCMLeaf.txt", sep = "\t", row.names = FALSE, quote = FALSE)
#LCMRoot
contrast.matrix.LCMRoot <- makeContrasts(LCMRoot = LCMyoungrootBplus - LCMyoungrootB0,levels=design)

fits.LCMRoot <- contrasts.fit(fit, contrast.matrix.LCMRoot)

#get bayesian stats for your linear model fit
ebFit.LCMRoot <- eBayes(fits.LCMRoot)

# TopTable to view DEGs -----
myTopHits.LCMRoot <- topTable(ebFit.LCMRoot, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.LCMRoot <- decideTests(ebFit.LCMRoot, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.LCMRoot)
summary(results.LCMRoot)
vennDiagram(results.LCMRoot, include="up")
upregulated_genes.LCMRoot <- rownames(ebFit.LCMRoot)[results.LCMRoot == 1]
write.table(upregulated_genes.LCMRoot, file = "upregulatedLCMRoot.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.LCMRoot <- rownames(ebFit.LCMRoot)[results.LCMRoot == -1]
write.table(downregulated_genes.LCMRoot, file = "downregulatedLCMRoot.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#Leaf
contrast.matrix.Leaf <- makeContrasts(Leaf = youngleafBplus - youngleafB0,levels=design)

fits.Leaf <- contrasts.fit(fit, contrast.matrix.Leaf)

#get bayesian stats for your linear model fit
ebFit.Leaf <- eBayes(fits.Leaf)

# TopTable to view DEGs -----
myTopHits.Leaf <- topTable(ebFit.Leaf, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.Leaf <- decideTests(ebFit.Leaf, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.Leaf)
summary(results.Leaf)
vennDiagram(results.Leaf, include="up")
upregulated_genes.Leaf <- rownames(ebFit.Leaf)[results.Leaf == 1]
write.table(upregulated_genes.Leaf, file = "upregulatedLeaf.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.Leaf <- rownames(ebFit.Leaf)[results.Leaf == -1]
write.table(downregulated_genes.Leaf, file = "downregulatedLeaf.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#MatureEmbryo
contrast.matrix.matemb <- makeContrasts(matemb = matembBplus - matembB0,levels=design)

fits.matemb <- contrasts.fit(fit, contrast.matrix.matemb)

#get bayesian stats for your linear model fit
ebFit.matemb <- eBayes(fits.matemb)

# TopTable to view DEGs -----
myTopHits.matemb <- topTable(ebFit.matemb, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.matemb <- decideTests(ebFit.matemb, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.matemb)
summary(results.matemb)
vennDiagram(results.matemb, include="up")
upregulated_genes.matemb <- rownames(ebFit.matemb)[results.Leaf == 1]
write.table(upregulated_genes.matemb, file = "upregulatedmatemb.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.matemb <- rownames(ebFit.matemb)[results.matemb == -1]
write.table(downregulated_genes.matemb, file = "downregulatedmatemb.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#Root
contrast.matrix.Root <- makeContrasts(Root = YoungRootBplus - YoungRootB0,levels=design)

fits.Root <- contrasts.fit(fit, contrast.matrix.Root)

#get bayesian stats for your linear model fit
ebFit.Root <- eBayes(fits.Root)

# TopTable to view DEGs -----
myTopHits.Root <- topTable(ebFit.Root, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.Root <- decideTests(ebFit.Root, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.Root)
summary(results.Root)
vennDiagram(results.Root, include="up")
upregulated_genes.Root <- rownames(ebFit.Root)[results.Root == 1]
write.table(upregulated_genes.Root, file = "upregulatedRoot.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.Root <- rownames(ebFit.Root)[results.LCMRoot == -1]
write.table(downregulated_genes.Root, file = "downregulatedRoot.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#YoungEmbryo
contrast.matrix.youngemb <- makeContrasts(youngemb = youngembBplus - youngembBO,levels=design)

fits.youngemb <- contrasts.fit(fit, contrast.matrix.youngemb)

#get bayesian stats for your linear model fit
ebFit.youngemb <- eBayes(fits.youngemb)

# TopTable to view DEGs -----
myTopHits.youngemb <- topTable(ebFit.youngemb, adjust ="BH", coef=1, number=Inf, sort.by="logFC")

# decideTests to pull out the DEGs and make Venn Diagram ----
results.youngemb <- decideTests(ebFit.youngemb, method="global", adjust.method="BH", p.value=0.01, lfc=1)
head(results.youngemb)
summary(results.youngemb)
vennDiagram(results.youngemb, include="up")
upregulated_genes.youngemb <- rownames(ebFit.youngemb)[results.Leaf == 1]
write.table(upregulated_genes.youngemb, file = "upregulatedyoungemb.txt", sep = "\t", row.names = FALSE, quote = FALSE)
downregulated_genes.youngemb <- rownames(ebFit.youngemb)[results.youngemb == -1]
write.table(downregulated_genes.youngemb, file = "downregulatedyoungemb.txt", sep = "\t", row.names = FALSE, quote = FALSE)
# Load the VennDiagram package
library(VennDiagram)

# Read the files into vectors
file1 <- scan("downregulatedLCMRoot.txt", what = "", sep = "\n")
file2 <- scan("downregulatedAR.txt", what = "", sep = "\n")
file3 <- scan("downregulatedyoungemb.txt", what = "", sep = "\n")
file4 <- scan("downregulatedmatemb.txt", what = "", sep = "\n")

# Create the Venn diagram
venn.diagram(
  x = list(File1 = file1, File2 = file2, File3 = file3, File4 = file4),
  category.names = c("LCM_Root", "AR", "Young_Emb", "Mat_Emb"),
  filename = "ven_downregulated",
  imagetype = "png",
  output = TRUE,
  main = "Intersection of dowregulated genes between 4 tissues",
  main.col = "red",
  fill = c("lightgreen", "lightblue", "lightsalmon", "yellow"),
  col = c("lightgreen", "lightblue", "lightsalmon", "yellow")
)

# Read upregulated gene lists from text files
genes_file1 <- read.table("downregulatedLCMRoot.txt", header = FALSE, stringsAsFactors = FALSE)$V1
genes_file2 <- read.table("downregulatedAR.txt", header = FALSE, stringsAsFactors = FALSE)$V1
genes_file3 <- read.table("downregulatedyoungemb.txt", header = FALSE, stringsAsFactors = FALSE)$V1
genes_file4 <- read.table("downregulatedmatemb.txt", header = FALSE, stringsAsFactors = FALSE)$V1

common_genes <- Reduce(intersect, list(genes_file1, genes_file2, genes_file3, genes_file4))
write.table(common_genes, file = "commonly_downregulated_genes.txt", sep = "\t", row.names = FALSE, quote = FALSE)

#Now subtract the genes which are "uncommon" between commanly downregulated genes and the three control tissues namely Leaf , Root and LCMLeaf
common_downregulated <- scan("commonly_downregulated_genes.txt", what = "", sep = "\n")
leaf <- scan("downregulatedLeaf.txt", what = "", sep = "\n")

# Create the Venn diagram
venn.diagram(
  x = list(common_downregulated, leaf),
  category.names = c("CDG", "Leaf"),
  filename = "downregulated_leaf_cdg",
  imagetype = "png",
  output = TRUE,
  main = "Intersection of commonly downregulated genes and Leaf",
  main.col = "red",
  fill = c("lightgreen", "yellow"),
  col = c("lightgreen", "yellow")
)

# Find uncommon genes between the two sets
genes_common_downregulated <- read.table("commonly_downregulated_genes.txt", header = FALSE, stringsAsFactors = FALSE)$V1
genes_leaf <- read.table("downregulatedLeaf.txt", header = FALSE, stringsAsFactors = FALSE)$V1

uncommon_cdg_leaf <- setdiff(genes_common_downregulated, genes_leaf)
write.table(uncommon_cdg_leaf, file = "uncommon_cdg_leaaf.txt", sep = "\t", row.names = FALSE, quote = FALSE)

uncommon_cdgleaf  <- scan("uncommon_cdg_leaaf.txt", what = "", sep = "\n")
root <- scan("downregulatedRoot.txt", what = "", sep = "\n")

venn.diagram(
  x = list(uncommon_cdgleaf, root),
  category.names = c("Uncommon_genes", "Root"),
  filename = "downregulated_root_uncdg",
  imagetype = "png",
  output = TRUE,
  main = "Intersection of uncommon genes and Root",
  main.col = "red",
  fill = c("lightgreen", "yellow"),
  col = c("lightgreen", "yellow")
)

#Find uncommon genes between the two sets
genes_uncommon_cdgleaf <- read.table("uncommon_cdg_leaaf.txt.txt", header = FALSE, stringsAsFactors = FALSE)$V1
genes_root <- read.table("downregulatedRoot.txt", header = FALSE, stringsAsFactors = FALSE)$V1

uncommon_genes_root <- setdiff(genes_uncommon_cdgleaf, genes_root)
write.table(uncommon_cdg, file = "uncommon_genes_root.txt", sep = "\t", row.names = FALSE, quote = FALSE)
#s.zumkeller@fz-juelich.de
https://uni-duesseldorf.sciebo.de/s/A1XymOeU5AB9kNx

Please use this link
